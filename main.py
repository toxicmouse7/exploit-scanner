import argparse
import ipaddress
import random
import socket
from time import sleep
from typing import List

import requests
import scapy.sendrecv
import socks
from requests import ConnectTimeout
from scapy.layers import inet
from scapy.packet import Packet

from IcmpCodes import IcmpCodes
from Responses import Responses
from TcpFlags import TcpFlags


def print_scan_result(port: int, proto: str, result: Responses) -> None:
    match result:
        case Responses.OF:
            print(f'{port}/{proto} opened / filtered')
        case Responses.OPEN:
            print(f'{port}/{proto} opened')
        case Responses.UNANSWERED:
            print(f'{port}/{proto} unanswered')
        case Responses.CLOSED:
            print(f'{port}/{proto} closed')
        case Responses.FILTERED:
            print(f'{port}/{proto} filtered')


def generate_ip_pool(ip_string: str) -> List[str]:
    ip_network = ipaddress.ip_network(ip_string)
    return [str(ip) for ip in ip_network]


def main():
    is_vuln_easy_chat_server("192.168.50.145", 80)
    parser = argparse.ArgumentParser(prog='port-scanner')

    parser.add_argument('network', type=str)
    parser.add_argument('--proto', required=True, choices=['tcp', 'udp'])
    parser.add_argument('--from', required=False, metavar='port', type=int)
    parser.add_argument('--to', required=False, metavar='port', type=int)
    parser.add_argument('--syn', required=False, action='store_true')
    parser.add_argument('--fin', required=False, action='store_true')
    parser.add_argument('--tor-address', required=False, type=str)
    parser.add_argument('--tor-port', required=False, type=int)
    parser.add_argument('--panic', required=False, action='store_true')

    args = vars(parser.parse_args())

    if args['to'] is not None and args['from'] is None or args['to'] is None and args['from'] is not None:
        print('Invalid port range')
        exit(-1)

    port_range = []
    if args['to'] is not None and args['from'] is not None:
        port_range = list(range(args['from'], args['to'] + 1))

    if args['tor-address']:
        socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, args['tor-address'],
                              args['tor-port'] if args['tor-port'] else 9050)
        socket.socket = socks.socksocket

    ip_pool = generate_ip_pool(args['network'])
    scan_for_open_ports(ip_pool, port_range, args['proto'], args['syn'], args['fin'])


def scan_for_open_ports(
        ip_pool: List[str],
        port_range: List[int],
        proto: str,
        syn: bool = False,
        fin: bool = False,
        panic: bool = False):
    if len(port_range) == 0:
        port_range = [22, 53, 80, 443, 3306, 5432]

    for ip_address in ip_pool:
        for port in port_range:
            if proto == 'tcp':
                tcp_result = scan_tcp_port(ip_address, port, syn, fin)
                print_scan_result(port, 'tcp', tcp_result)
                if tcp_result == Responses.OPEN:
                    is_vuln_easy_chat_server(ip_address, port)
            elif proto == 'udp':
                udp_result = scan_udp_port(ip_address, port)
                print_scan_result(port, 'udp', udp_result)
            if panic:
                sleep(random.uniform(0, 10))


def scan_tcp_port(host: str, port: int, syn: bool, fin: bool) -> Responses:
    if fin and syn:
        raise Exception("Can't use fin and sin at one time")

    ip = inet.IP(dst=host)
    tcp = inet.TCP(dport=port, flags='S' if syn else 'F' if fin else '')
    packet: Packet = ip / tcp

    answered = scapy.sendrecv.sr1(packet, timeout=2, verbose=0)

    if not answered:
        return Responses.UNANSWERED
    elif answered.haslayer(inet.TCP):
        if answered.getlayer(inet.TCP).flags == TcpFlags.SYNC_ACK:
            return Responses.OPEN
        elif answered.getlayer(inet.TCP).flags == TcpFlags.RST_PSH:
            return Responses.CLOSED
    elif answered.haslayer(inet.ICMP):
        icmp_type = answered.getlayer(inet.ICMP).type
        if icmp_type == IcmpCodes.PortIsUnreachable:
            return Responses.FILTERED


def is_vuln_easy_chat_server(host: str, port: int) -> bool:
    try:
        response = requests.get(f'http://{host}:{port}', timeout=3)
        if 'Easy Chat Server' in response.headers.get('Server'):
            return True
    except ConnectTimeout:
        return False


def scan_udp_port(host: str, port: int) -> Responses | None:
    ip = inet.IP(dst=host)
    udp = inet.UDP(dport=port)
    packet: Packet = ip / udp

    answered = scapy.sendrecv.sr1(packet, timeout=2, verbose=0)

    if answered is None:
        return Responses.OF
    else:
        if answered.haslayer(inet.ICMP):
            return Responses.CLOSED
        elif answered.haslayer(inet.UDP):
            return Responses.OF
        else:
            return None


if __name__ == '__main__':
    main()
